######################################################################################
##
## Arsalan Akram Malik, Dmytro Savchuk Â© 2023 - 2024
##

######################################################################################

##  Throughout this document, we use the group <H> generated by the following automaton for examples.
##  H := AutomatonGroup("e = (f,e,1)(2,3) , f = (1,e,f)(1,2,3)");

##  <deg> denotes the degree of tree. 

##  We use rewritting systems with parameter 2. This implies that we consider all relations among words of length 2 
##  for our computations. This is done by the following command:  
##  AG_UseRewritingSystem(H);

##  In our examples we denote the elements of <H> given by words <e*f> and <f*f*e> by <p> and <q> respectively.
##  This is done as follows:
##  p := e*f ;
##  q := f*f*e ;

##  We also define <p_mask> and <q_mask> as follows: 
##  p_mask := mask_function(e*f,2);
##  q_mask := mask_function(f*f*e,2);
##  We will elaborate on it when we define the function <mask_function> later in this document.


######################################################################################
##
#O  Random_Element( <len>, <group>)
##
##  This function uses generators (and their inverses) of an automaton group to generate
##  a random element of group <group> with reduced word length <len>. 
##  Rewriting systems can be used bofore this function to add relators of required length in generating elements.  
##  
##  \beginexample
##  
##  gap> Random_Element(7,H);
##  e*f^-1*e^2*f^2*e^-1
##   
##  \endexample
##

Random_Element := function(len , group)

    local i , j , generators , gen_inv , randomelt ;

    generators := GeneratorsOfGroup(group) ;
    gen_inv    := [] ;

    for i in [1..Length(generators)]
        do 
            Append(gen_inv , [(generators[i])^(-1)]);
        od;
    Append(gen_inv , generators);
    #Print(gen_inv , "\n") ;
    

    randomelt := One(group) ;
    j         := 0 ;

    while j < len 
        do 
            randomelt := randomelt * Random(gen_inv) ;
            j := Length(Word(randomelt)) ;
        od;
    return randomelt ;

end;


######################################################################################
##
#O  mask_function( <group_element>, <fixed_depth>)
##
##  This function takes a group element <group_element> and a positive interger <fixed_depth> as input and
##  returns a list with two entries. First entry is a list of boundary elements of the element portrait at 
##  level <fixed_depth>. The second entry is the permutation induced at that level.
##
##  If <fixed_depth> equals zero then the function reads it as one. 
##
##  We frequently use the output of this function and refer to this as "mask format" in the remaining document.
##  Where it is relevant, we also mention the <fixed_depth> of a group element written in this format. 
##  
##  \beginexample
##  
##  gap> mask_function(e*f,2);
##  [ [ 1, e, f, f, e*f, e, f, e, 1 ], (1,5)(2,6,3,4)(8,9) ]
##   
##  \endexample
##

#Takes an element of group and 'depth' to retrun a list containing boundary and perrmutation induced at that level. 
mask_function := function(group_element , fixed_depth) 

    local decomposition ;

    decomposition := [] ;

    if fixed_depth = 0 then

        decomposition[1] := Sections(group_element, 1) ;
        decomposition[2] := PermOnLevel(group_element, 1) ;
 
    else 

        decomposition[1] := Sections(group_element, fixed_depth) ;
        decomposition[2] := PermOnLevel(group_element, fixed_depth) ;
    fi;

    return decomposition;
end;

######################################################################################
##
#O  permutation_extension_no_switch( <permutation>, <boundary_length> , <deg>)
##
##  Given a permutation <permutation> induced at level log_<deg>_<boundary_length> of a tree of degree <deg>,
##  this function extends the permutation to next level (log_<deg>_<boundary_length>) + 1 assuming trivial
##  permutations at all boundary nodes of the tree.   
 
##  
##  \beginexample
##  
##  gap>  permutation_extension_no_switch((1,5)(2,6,3,4)(8,9), 9 , 3);
##  (1,13)(2,14)(3,15)(4,16,7,10)(5,17,8,11)(6,18,9,12)(22,25)(23,26)(24,27)
##   
##  \endexample
##

permutation_extension_no_switch := function(permutation , boundary_length , deg) 

    local i , initial_list_perm , extended_list_perm ;

    initial_list_perm  := ListPerm(permutation , boundary_length) ;

    extended_list_perm := [] ;

        for i in initial_list_perm 
            do 
                Append(extended_list_perm , [(deg*i)-(deg-1) .. deg*i]) ;
            od;
        return PermList(extended_list_perm);
end;


#function that uses location, level and permutation induced by the element to give the permuation at next level by that element. 
#general_next_level_permuation := function( mask_element , d)

#NOT required : function to return new permutation as list given the location 'i' and 'd'
next_perm_list := function(perm, location , deg)

    local i , j , list , new_list , plain_list , new_perm ;

    plain_list := [location*deg - (deg-1) .. location*deg] ;
    list       := ListPerm(perm, deg) ;
    new_list   := [] ; 
    new_perm := () ;

    for i in list
        do
            Append(new_list , [(location*deg) - (deg-i)]);
        od;
    return new_list; #new_perm * MappingPermListList(plain_list , new_list);
end;

######################################################################################
##
#O  next_perm_one_location( <perm>, <location> , <deg>)
##  
##  We define <location> of nodes of a tree at first level. The left most node has <location> = 1. The <location>
##  increases by a unit as we move from left to right. The right most node has <location> = <deg>. 
##  Given a permuation <perm> induced by an element at the node <location> of a tree of degree <deg>,
##  this function returns the permutation induced at the second level of the tree by <perm> at node <location>.  
##  
##  \beginexample
##  
##  gap>  next_perm_one_location( (2,1,3) , 2 ,3);
##  (4,6,5)
##   
##  \endexample
##


next_perm_one_location := function(perm, location , deg)

    local i , j , list , new_list , plain_list , new_perm ;

    plain_list := [location*deg - (deg-1) .. location*deg] ;
    list       := ListPerm(perm, deg) ;
    new_list   := [] ; 
    new_perm := () ;

    for i in list
        do
            Append(new_list , [(location*deg) - (deg-i)]);
        od;

    #for j in new_list
    return new_perm * MappingPermListList(plain_list , new_list);
end;

######################################################################################
##
#O  permutation_generator_next_level( <mask_element>, <deg>)
##
##  This function takes a group element <mask_element> in the "mask format" as defined by the function
##  <mask_function> at some level n and degree to tree <deg> as input. 
##  It returns the permutation induced at the next level n+1.
##  
##  \beginexample
##  
##  gap>  permutation_generator_next_level([ [ f, e, One(H), f*e, e*f, e*f, e, e, f^2 ], (1,4,3,5,2,6)(7,9) ],3);
##  (1,11,8,14,4,16,2,12,7,13,5,18,3,10,9,15,6,17)(19,25,21,26)(20,27)(23,24)
##   
##  \endexample
##

permutation_generator_next_level := function(mask_element , deg)

    local i , j , no_switch_ext , next_level_perm  ;

    no_switch_ext    := permutation_extension_no_switch(mask_element[2] , Length(mask_element[1]) , deg ) ;

    next_level_perm := () ;

    for i in [1..Length(mask_element[1])] 
        do 
            next_level_perm := next_level_perm * next_perm_one_location(PermOnLevel(mask_element[1][i] , 1) , i , deg) ;
        od;
    return next_level_perm*no_switch_ext ;
end;

######################################################################################
##
#O  mask_one_ext_boundary( <mask_element>)
##
##  This function takes a group element <mask_element> in the "mask format" as defined by the function
##  <mask_function> at some level n, as input. 
##  It returns the boundary(leaves) at the next level n+1.
##  
##  \beginexample
##  
##  gap>  mask_one_ext_boundary([ [ One(H), e, f, f, e*f, e, f, e, One(H) ], (1,5)(2,6,3,4)(8,9) ]);
##  [ 1, 1, 1, f, e, 1, 1, e, f, 1, e, f, f, e*f, e, f, e, 1, 1, e, f, f, e, 1, 1, 1, 1 ]
##   
##  \endexample
##

mask_one_ext_boundary := function(mask_element) 

    local i, new_boundary ;

    new_boundary := [] ;

    for i in mask_element[1]

        do 
            Append (new_boundary , Sections(i)) ; 
        od;

    return new_boundary ;
end;

######################################################################################
##
#O  mask_one_ext( <mask_element> , <deg>)
##
##  This function takes a group element <mask_element> in the "mask format" as defined by the function
##  <mask_function> at some level n and the degree <deg> of tree as input. 
##  It returns the "mask format" of the element for the next level n+1.
##  
##  \beginexample
##  
##  gap>  mask_one_ext([ [ One(H), e, f, f, e*f, e, f, e, One(H) ], (1,5)(2,6,3,4)(8,9) ],3);
##  [ [ 1, 1, 1, f, e, 1, 1, e, f, 1, e, f, f, e*f, e, f, e, 1, 1, e, f, f, e, 1, 1, 1, 1 ],
##  (1,13,2,14)(3,15)(4,16,7,11,6,17,9,10,5,18,8,12)(19,20,21)(22,25)(23,27,24,26) ]
##   
##  \endexample
##

mask_one_ext := function(mask_element , deg)

    local ext ;

    ext := [mask_one_ext_boundary(mask_element) , permutation_generator_next_level(mask_element , deg )] ;

    return ext ;
end;

######################################################################################
##
#O  mask_product( <mask1> , <mask2>)
##
##  This function takes two group elements <mask1> and <mask2> in the "mask format" at the same <fixed_depth>
##  as defined by the function <mask_function>.
##  It returns the "mask format" of the group product of these elements in "mask format" for the same <fixed_depth>.
##  
##  \beginexample
##  
##  gap> p_mask := mask_function(e*f,2);
##  gap> q_mask := mask_function(f*f*e,2);
##
##  gap> mask_product(p_mask , q_mask);
##  [ [ e*f, e^2*f, f^2*e, f*e, e*f^2, e, f*e, e*f^2, e ], (1,2)(4,6,5)(7,9,8) ]
##  
##  \endexample
##

mask_product := function(mask1, mask2)

    local product_boundary , product , i ;

    product_boundary := [] ;
    product          := [product_boundary , mask1[2]*mask2[2]] ;

    for i in [1.. Length(mask1[1])]
        do 
        product_boundary[i] := mask1[1][i] *mask2[1][i^mask1[2]] ;
        od;
    return product;
end;

######################################################################################
##
#O  mask_product( <mask_element> , <deg>)
##
##  This function takes a group element in the "mask format" and degree <deg> of the tree.
##  It returns the <fixed_depth> as defined in the function <mask_function> for the <mask_element>.
##  
##  \beginexample
##  
##  gap>  mask_depth([ [ One(H), e, f, f, e*f, e, f, e, One(H) ], (1,5)(2,6,3,4)(8,9) ],3);
##  2
##  
##  \endexample
##

mask_depth := function(mask_element , deg)

    local n , check ;

    n := 0;

    check := function(n)

        if deg^n = Length(mask_element[1]) then 

            return n ;

        else 
        
            n := n + 1 ;
            return check(n) ;
        fi;
    end;

    return check(n) ;

end;

######################################################################################
##
#O  mask_product_diff_depth( <mask1> , <mask2> , <deg>)
##
##  This function takes two group elements in the "mask format" <mask1> and <mask2> and degree <deg> of the tree.
##  It returns group product of the two elements in the "mask format" at the maximum value of <fixed_depth> as defined 
##  in the function <mask_function> for the two elements. 
##  
##  \beginexample
##  
##  gap>   mask_product_diff_depth([ [ One(H), e, f, f, e*f, e, f, e, One(H) ], (1,5)(2,6,3,4)(8,9) ] ,[ [ e, e*f^2, f*e ], (1,2) ],3);
##  [ [ e*f, e^2*f, f^2*e, f*e, e*f^2, e, f*e, e*f^2, e ], (1,2)(4,6,5)(7,9,8) ]
##  
##  \endexample
##


mask_product_diff_depth := function(mask1 , mask2 , deg) 

    local i , d1 , d2 , d_max , mask1_new , mask2_new;

    d1 := mask_depth(mask1 ,deg) ;
    d2 := mask_depth(mask2 ,deg) ;
    d_max  := Maximum(d1,d2) ;

    mask1_new := mask1 ;
    mask2_new := mask2 ;
    

        if d1 = d2 then 
            return mask_product(mask1 , mask2) ;

        else
            while d1 < d_max 
                do
                    mask1_new := mask_one_ext(mask1_new ,deg) ;
                    d1        := mask_depth(mask1_new ,deg) ;
                od;

            while d2 < d_max
                do 
                    mask2_new := mask_one_ext(mask2_new ,deg) ;
                    d2        := mask_depth(mask2_new ,deg) ;
                od;
        fi; 
    
    return mask_product(mask1_new , mask2_new) ;
end;

######################################################################################
##
#O  mask_vector_generator_diff_depth( <k> , <len> , <group>)
##
##  This function takes two positive integers <k> and <len>, and a group <group> as input.
##  It randomly generates <k> elements of the group <group> each of reduced word length <len> as defined in the function
##  <Random_Element> and returns them in "mask format" where the <fixed_depth> for each element as defined in the 
##  function <mask_function> is depth of the reduced portrait for that element. The output is a list with <ken> entries.
##  Each entry corresponds to a randomly generated element in "mask format". 
##  
##  In the following example, before the final output, we have printed the randomly generated group elements 
##  as reduced words in line-1 and their respective portrait depths in line-2 of GAP output. This is followed by 
##  list of the randomly generated elements in "mask format".
##  
##
##  \beginexample
##  
##  gap> mask_vector_generator_diff_depth(3,5,H);
##  [ e*f^-1*e^2*f, (f*e^-1)^2*e^-1, e^2*f^2*e^-1 ]
##  [ 3, 0, 3 ]
##  [ [ [ 1, e, f, f, e*f, e, f, e, 1, e, e*f, f, f, e, 1, f, e, 1, f, e, 1, f, e*f, e, 1, e, f ],
##  (1,5)(2,6,3,4)(8,9)(10,21,17,27,13,22,11,19,16,25,14,24,12,20,18,26,15,23) ], [ [ f^-1, 1, e^-1 ], (2,3) ],
##  [ [ f, e, 1, f, e*f, e, 1, e, f, e, e*f, f, f, e, 1, f, e, 1, 1, e, f, f, e*f, e, f, e, 1 ],
##  (1,16,7,14,6,12,2,18,8,15,5,10,3,17,9,13,4,11)(19,23)(20,24,21,22)(26,27) ] ]
##
##  \endexample
##

#generate vector of masked elements , masked at depth of there portrait depths
mask_vector_generator_diff_depth := function( k , len , group )
    local i , j , t , random , p_depth , v ;

    random  := [] ;
    p_depth := [] ;
    v       := [] ;

    for i in [1..k] do 
        random[i] := Random_Element(len , group) ;
        od;
        Print(random,"\n"); 

    for j in [1..k] do 
        p_depth[j] := AutomPortraitDepth(random[j]);
        od;
        Print(p_depth,"\n");

    for t in [1..k] do 
        v[t] := mask_function(random[t], p_depth[t]);
        od;
		
    return v ;
end;

#alternative implementation (same time complexity)
mask_vector_generator_diff_depth2 := function(k, len, group)
	local random;
	random:=List([1..k], x -> Random_Element(len,group));
	return List([1..k], x -> mask_function(random[x],AutomPortraitDepth(random[x])));
end;

######################################################################################
##
#O  mask_inverse( <mask_element>)
##
##  This function takes a group element in the "mask format" <mask_element> and returns its inverse 
##  in "mask format" at the same <fixed_depth> as the input. 
##  
##  \beginexample
##  
##  gap> mask_inverse([ [ e*f, e^2*f, f^2*e, f*e, e*f^2, e, f*e, e*f^2, e ], (1,2)(4,6,5)(7,9,8) ]);
##  [ [ f^-1*e^-2, f^-1*e^-1, e^-1*f^-2, f^-2*e^-1, e^-1, e^-1*f^-1, f^-2*e^-1, e^-1, e^-1*f^-1 ], (1,2)(4,5,6)(7,8,9) ]
##  
##  \endexample
##

mask_inverse := function(mask_element)
    local i , lp , inverse , inverse_boundary;

    lp := Length(mask_element[1]) ;
    inverse_boundary := [] ;
    inverse := [inverse_boundary, (mask_element[2])^(-1) ] ;

    for i in [1..lp]
        do 
            inverse_boundary[i] := mask_element[1][i^((mask_element[2])^(-1))] ;
            inverse_boundary[i] := (inverse_boundary[i])^(-1) ;
        od;
    return inverse ;
end;

#alternative implementation (same time complexity)
mask_inverse2:= function(mask_element)
	local aut_inv;
	aut_inv:=TreeAutomorphism(mask_element[1],mask_element[2])^-1;
	return [Sections(aut_inv,1),PermOnLevel(aut_inv,1)];
end;

######################################################################################
##
#O  mask_conjugation_diff_depth( <mask_element>, <mask_conjugator>, <deg>)
##
##  This function takes two group elements in the "mask format" <mask_element> and <mask_conjugator>, and the degree
##  of tree <deg> as input.
##  Output is the "mask format" for <mask_element> conjugated by <mask_conjugator>. The <fixed_depth> for the output
##  is the maximum of <fixed_depth> for inputs.  
##  
##  \beginexample
##  
##  gap>  mask_conjugation_diff_depth([ [ f, e, One(H), f*e, e*f, e*f, e, e, f^2 ], (1,4,3,5,2,6)(7,9) ],[ [ f, e*f, e ], (1,2) ],3);
##  [ [ e, e*f, f, f^-1*e*f, f^2, e, f^-1*e, f^3, e ], (1,6,3,5,2,4)(7,8) ]
##  
##  \endexample
##

mask_conjugation_diff_depth := function(mask_element, mask_conjugator ,deg)

    
    local mask_conjugated ;
    mask_conjugated := mask_product_diff_depth(mask_inverse(mask_conjugator),mask_product_diff_depth(mask_element,mask_conjugator,deg) ,deg) ;

    return mask_conjugated ;
end;

######################################################################################
##
#O  mask_vector_conjugation_diff_depth( <v>, <r>, <deg>)
##
##  Input for this function is a list <v> where each entry of the list is a group element in "mask format" 
##  (with possibly different <fixec_depth>), a group element <r> in "mask format" and the degree of tree <deg>.
##  Each entry of <v> is conjugated by <r> and returned as list in "mask format".   
##  
##  In the following example we randomly generate the input list <v> for the function using yet another function defined 
##  earlier in the document <mask_vector_generator_diff_depth>.
##  The first and second line of output prints the randomly generated group elements in the input list <v>
##  as reduced words and their reduced portrait depths respectively. 
##
##  \beginexample
##  
##  gap>  mask_vector_conjugation_diff_depth(mask_vector_generator_diff_depth(2,3,H),p_mask,3);
##  [ f*e*f, f^-1*e*f^-1 ]
##  [ 3, 0 ]
##  [ [ [ f^-1, f, 1, e, e*f, f, 1, 1, 1, f^-1*e, f, f, e, e, f^2, 1, e, f, f^-1*e, f^2, 1, e*f, e^2, f^2, e, e*f, f ],
##  (1,26,4,21,8,23,3,27,5,19,9,24,2,25,6,20,7,22)(10,12)(13,18)(14,17,15,16) ],
##  [ [ f^-1, 1, e^-1, f^-1, 1, e^-1, f^-1, f, 1 ], (1,9,3,8)(2,7)(4,6,5) ] ]
##
##  \endexample
##

mask_vector_conjugation_diff_depth := function(v ,r ,deg)
    local i , mask_conjugated_vector;

    mask_conjugated_vector := [] ;

    for i in [1..Length(v)]
        do 
            mask_conjugated_vector[i] := mask_conjugation_diff_depth(v[i] , r ,deg) ;
        od;
    return mask_conjugated_vector;
end;

######################################################################################
##
#O  mask_output_diff_depth( <v>, <u>, <deg>)
##
##  This function takes lists <v> and <u> with equal number of entries. Each entry is group element in "mask format"
##  at possibly different <fixed_depth> compared to others. <deg> is the degree of tree. 
##  Output is a list of group elements in "mask_format". Each entry is the product of the corresponding  entry
##  of <v> multiplied by the inverse of the respective entry of <u>.  
##  
##  In the following example we randomly generate the input list <v> and <u> for the function using yet another
##  function defined earlier in the document <mask_vector_generator_diff_depth>.
##  
##  The first and second line of output prints the randomly generated group elements in the input list <v>
##  as reduced words and their reduced portrait depths respectively.
##  The third and fourth line of output prints the randomly generated group elements in the input list <u>
##  as reduced words and their reduced portrait depths respectively.
##
##  \beginexample
##  
##  gap>  mask_output_diff_depth(mask_vector_generator_diff_depth(2,3,H),mask_vector_generator_diff_depth(2,3,H),3);
##  [ e^-1*f*e, e^-1*f^2 ]
##  [ 2, 2 ]
##  [ e*f^-1*e, f^-1*e^-1*f^-1 ]
##  [ 0, 3 ]
##  [ [ [ f^-1, 1, e^-1, 1, e, f, 1, 1, 1 ], (1,6,7)(2,4,8)(3,5,9) ],
##  [ [ f^-1*e, f, f, e, e, f^2, 1, e, f, f, e, 1, f^2, e, e, e*f, e*f, f*e, f, e*f, e, f^2, e, e, e, e*f, f ],
##  (1,12,23,8,15,27,5,17,20)(2,11,24,9,13,25,6,16,19)(3,10,22,7,14,26,4,18,21) ] ]
##
##  \endexample
##

mask_output_diff_depth := function(v,u,d)

    local i, w ;

    w := [] ;

    for i in [1..Length(v)]
        do 
            w[i] := mask_product_diff_depth(v[i], mask_inverse(u[i]),d) ;
        od;
    return w;
end;

######################################################################################
######################################################################################
# 'new_depth' COMPLEXITY CONSTRUCTION IN THE NEXT 200 LINES
######################################################################################
######################################################################################



######################################################################################
##
#O  check_and_extend( <mask_element>, <deg>, <group>)
##
##  Input for this function is a group element in "mask format" <mask_element> , the degree of tree <deg> and
##  the group <group>.
##  This function increases the <fixed_depth> of the <mask_element> until all leaves are elements of the Group Nucleus.
##  Using a contracting group <group> ensures that this process terminates. 
##  If all leaves are already in the Group Nucleus then it returns <mask_element>.
##  
##  \beginexample
##  
##  gap> check_and_extend([ [ e*f, e^2, f^2 ], (2,3) ],3 ,H); 
##  [ [ 1, e, f, f, e*f, e, f, e, 1, e, e*f, f, f, e, 1, f, e, 1, f, e, 1, f, e*f, e, 1, e, f ],
##  (1,5)(2,6,3,4)(8,9)(10,21,17,27,13,22,11,19,16,25,14,24,12,20,18,26,15,23) ] 
##
##  \endexample
##

check_and_extend := function(mask_element , deg , group)

    local j , checklist , temp_boundary ;

    checklist     := GroupNucleus(group) ; 
    temp_boundary := mask_element ;

    for j in temp_boundary[1]
        do
            if (j in checklist) = false then

                temp_boundary := mask_one_ext(temp_boundary , deg) ;

            return check_and_extend(temp_boundary , deg , group);
        
            fi;
        od;
    return temp_boundary ;
end;

######################################################################################
##
#O  mask_group_nucleus(<group>)
##
##  The input of this function is the group <group>. 
##  The output is a list with number of entries equal to the number of elements in the Group Nucleus. 
##  Each entry in the list is a list with three entries. The first entry is a word representing an element of the nucleus,
##  the second and third entry correspond to the sections and permutation induced by that element at level-1.
##  
##  \beginexample
##  
##  gap>  mask_group_nucleus(H);
##  [ [ 1, [ 1, 1, 1 ], () ], [ e, [ f, e, 1 ], (2,3) ], [ f, [ 1, e, f ], (1,2,3) ], [ f^-1, [ f^-1, 1, e^-1 ], (1,3,2) ],
##  [ e^-1, [ f^-1, 1, e^-1 ], (2,3) ], [ e*f, [ f, e*f, e ], (1,2) ], [ f^-1*e^-1, [ f^-1*e^-1, f^-1, e^-1 ], (1,2) ] ]
##
##  \endexample
##

mask_group_nucleus := function(group)

    local i , nucleus_list , nucleus_list_decompose ;

    nucleus_list_decompose := [] ;
    nucleus_list           := GroupNucleus(group) ;

    for i in [1..Length(nucleus_list)] 
        do 
            nucleus_list_decompose[i] := [nucleus_list[i] , Sections(nucleus_list[i]) , PermOnLevel(nucleus_list[i],1)] ;
        od;
    return nucleus_list_decompose ;
end;

#alternative implementation (same time complexity)
mask_group_nucleus2 := function(group)
    return List(GroupNucleus(group),x->[x,Sections(x), PermOnLevel(x,1)]) ;
end;


######################################################################################
##
#O  general_caret(<mask_element>,<deg>)
##
##  Input for this function is a group element in the "mask element" format and the degree <deg> of tree. 
##  This function considers the parent nodes of the leaves of the <mask_element> (given at any 
##  level <fixed_depth>) and returns a list of integers corresponding to the mapping induced by permutation
##  at the parent node.
##  The outpout begins with mapping  at the left most parent node. This is given by the first <deg> entries of output
##
##  \beginexample
##  
##  gap>  general_caret(p_mask,3);
##  [ 2, 3, 1, 2, 1, 3, 1, 3, 2 ]
##
##  \endexample
##

general_caret := function(mask_element, deg)

    local i , j , l , positions , perm , ref_list , check_list , perm_list , int_list , correction ; 

    ref_list  := [1..deg] ;
    positions := [1..Maximum(1,Length(mask_element[1])/deg)] ;
    l         := Length(mask_element[1]) ;
    perm      := mask_element[2] ;
    check_list:= [] ;
    perm_list := [] ;
    int_list  := [] ;

    for i in positions 
        do
            for j in [1..deg]
                do 
                    Append(int_list, [((i-1)*deg +j)^perm]);
                od;
        od;
    
    check_list := List(int_list , x -> x mod deg) ;

    correction := function(some_list)

        local k , no_zero_list ;

        no_zero_list := [] ; 

        for k in [1..Length(some_list) ]
            do
                if some_list[k] = 0 then 
                        no_zero_list[k] := deg;
                else 
                    no_zero_list[k] := some_list[k] ;
                fi;
            od;
        return  no_zero_list;
    end;

    perm_list := correction(check_list);

    return perm_list;
end;

######################################################################################
##
#O  generate_caret(<mask_element>, <deg>)
##
##  Input of this function a group element in "mask form" and degree <deg> of tree. 
##  The output is list of permutations induced at the parent nodes of leaves of the <mask_element> i.e. 
##   at level <fixed_depth> minus one. 
##
##  \beginexample
##  
##  gap> generate_caret(p_mask,3);
##  [ (1,2,3), (1,2), (2,3) ]
##
##  \endexample
##
 
#function that takes the list and generates the corresponding permutations

generate_caret := function(mask_element , deg)

    local i , ref_list , perm_list , positions , local_perms ;

    ref_list    := [1..deg] ;
    #Print(ref_list, "\n");

    perm_list   := general_caret(mask_element , deg) ;
    #Print(perm_list, "\n");

    positions   := [1..Maximum(1,Length(mask_element[1])/deg)] ;
    #Print(positions, "\n");

    local_perms := [] ;

    for i in positions
        do
            local_perms[i] := PermListList(ref_list , perm_list{[(i-1)*(deg)+1..(i-1)*(deg)+deg]}) ;
        od;
    return local_perms;
end;

######################################################################################
##
#O  general_local_decomp(<mask_element>, <deg>)
##
##  Input is a group element <mask_element> in "mask format" and degree of tree <deg>.
##  Output is a list of the parent nodes of leaves of the <mask_element> expressed in "mask_format" with 
##  <fixed_depth> parameter equal to 1. 
##
##  \beginexample
##  
##  gap> general_local_decomp(p_mask,3);
##  [ [ [ 1, e, f ], (1,2,3) ], [ [ f, e*f, e ], (1,2) ], [ [ f, e, 1 ], (2,3) ] ]
##
##  \endexample
##

#takes the mask element and returns a list with local decompositions of the masked element
general_local_decomp := function(mask_element, deg)

    local i , positions , local_decomp , local_perms , local_sections_list ;

    if Length(mask_element[1]) = 1 then 
        return mask_element;
    fi;

    positions           := [1..Length(mask_element[1])/deg] ;
    local_decomp        := [] ;
    local_perms         := generate_caret(mask_element , deg) ;
    local_sections_list := mask_element[1] ;

    for i in positions
        do
            local_decomp[i] := [local_sections_list{[(i-1)*(deg)+1..(i-1)*(deg)+deg]} , local_perms[i]] ;
        od;
    return local_decomp ;
end;

######################################################################################
##
#O  replacement_position_snip(<mask_element>, <deg>, <group>)
##
##  Input is group element in "mask format" , degree of tree <deg> and the group <group>.
##  The function considers the parent nodes of leaves of the <mask_element> and returns <true> if all 
##  parent nodes belong to the Group Nuclues. Otherwise, it returns <false>.
##
##  \beginexample
##  
##  gap> replacement_postition_snip(p_mask,3,H);'
##  true
##
##  \endexample
##

replacement_postition_snip := function(mask_element , deg , group)

    local i , nucleus , nucleus_list_decompose , check_list , j , snip_list ;

    snip_list := [] ;
    nucleus   := GroupNucleus(group) ;
    nucleus_list_decompose := [] ;
    check_list := general_local_decomp(mask_element , deg) ;

    for i in [1..Length(nucleus)] 
        do 
            nucleus_list_decompose[i] := [Sections(nucleus[i]) , PermOnLevel(nucleus[i],1)] ;
        od;

    snip_list := [] ;

    for j in [1..Length(check_list)]
        do
            if check_list[j] in nucleus_list_decompose then
            snip_list[j] := 1 ;
            else 
            snip_list[j] := 0;
            fi;
        od;
    #Print(snip_list , "\n") ;
    return ForAll(snip_list , x-> x = 1);
end;

######################################################################################
##
#O  level_up_mask_generator(<mask_element>, <deg>, <group>)
##
##  This function take a group element in "mask format" at some level "n", the degree <deg> of tree
##  and the group <group> as input.
##  The output is the group element in "mask formt" at level "n - 1" if all leaves the level "n" 
##  belong to the nucleus of the group <group>. 
##
##  \beginexample
##  gap>  H := AutomatonGroup("e = (f,e,1)(2,3) , f = (1,e,f)(1,2,3)");
##  < e, f >
##  gap> level_up_mask_generator([ [ f, e, One(H), f*e, e*f, e*f, e, e, f^2 ], (1,4,3,5,2,6)(7,9) ],3,H);
##  [ [ e ], (1,2) ]
##  \endexample
##

level_up_mask_generator := function(mask_element , deg , group) 

    local i , j , generator_checklist, new_boundary , local_decomp , identifier , initial_depth ; 

    if Length(mask_element[1]) = 1 then
        return mask_element ;
    fi;

    generator_checklist := mask_group_nucleus(group) ;
    #Print(generator_checklist,"\n") ;

    local_decomp        := general_local_decomp(mask_element,deg) ;
    #Print(local_decomp,"\n") ;

    initial_depth       := mask_depth(mask_element,deg) ;

    new_boundary        := [] ;

    for i in [1..Length(mask_element[1])/deg] 
        do
            for j in [1..Length(generator_checklist)]
                do
                    if local_decomp[i] = generator_checklist[j]{[2,3]} then
                        new_boundary[i] := generator_checklist[j][1] ;
                    fi;
                od;
        od;     
    return [new_boundary , PermActionOnLevel(mask_element[2] , initial_depth , initial_depth-1 ,deg  )] ;
end;

######################################################################################
##
#O  general_new_depth(<mask_element>, <deg>, <group>)
##
##  This function takes a group element <mask_element> in "mask format" at any level, the degree <deg> of tree and
##  group <group> as input.
##  It returns the depth of the reduced portrat for the group element. 
##
##  \beginexample
##  gap>  H := AutomatonGroup("e = (f,e,1)(2,3) , f = (1,e,f)(1,2,3)");
##  < e, f >
##  gap>  general_new_depth([ [ f, e, One(H), f*e, e*f, e*f, e, e, f^2 ], (1,4,3,5,2,6)(7,9) ],3,H);
##  4
##  \endexample
##

general_new_depth := function(mask_element , deg , group)

    local i , int_mask_element ;

    int_mask_element := mask_element ;

    if Length(mask_element[1]) = 1 then
        return 1;
    fi;

    while replacement_postition_snip(int_mask_element , deg ,group) = true
        do 
            int_mask_element := level_up_mask_generator(int_mask_element, deg , group) ;
        od;
        #return mask_depth(int_mask_element , d) ;

    if replacement_postition_snip(int_mask_element , deg , group ) = false then
        
        int_mask_element := check_and_extend(int_mask_element , deg , group) ;
    fi;

    return mask_depth(int_mask_element ,deg ) ;
end;



######################################################################################
######################################################################################

######################################################################################
##
#O  mask_BinaryVector(<v>, <deg>, <group>)
##
##  This function takes a vector <v> comprising of group elements <mask_element> in "mask format" at any level, the degree <deg> of tree and
##  group <group> as input.
##  It returns a vector where each entry corresponds to depth of the reduced portrat for entries of the input vector <v>. 
##
##  \beginexample
##  gap>  H := AutomatonGroup("e = (f,e,1)(2,3) , f = (1,e,f)(1,2,3)");
##  < e, f >
##  gap>  mask_BinaryVector([mask_function(e*f,2),mask_function(f*f*e,2)],3,H);
##  [ 0, 4 ]
##  \endexample
##

mask_BinaryVector := function (v , d , group) 

    local w , j ;

    w := [] ;

    for j in [1..Length(v)] 
        do
            w[j] := general_new_depth(v[j] , d ,group) ;
        od;
    return w ;
end; 

#alternative implementation (same time complexity)
mask_BinaryVector2 := function (v , d , group) 
	return List(v,x->general_new_depth(x , d ,group));
end;


######################################################################################
##
#O  mask_CheckVector(<v>)
##
##  This function takes a vector <v> as input.
##  It returns a vector of zeros <0> of the same length as the input <v>.  
##
##  \beginexample
##  gap>  H := AutomatonGroup("e = (f,e,1)(2,3) , f = (1,e,f)(1,2,3)");
##  < e, f >
##  gap>  mask_CheckVector([e*f , f*f*e , e*f*f]);
##  [ 0, 0, 0 ]
##  \endexample
##

mask_CheckVector := function (v)

    local w , j ;

    w := [] ;

    for j in [1..Length(v)] 
        do
        w[j] := 0 ;
        od;
    return w ;
end;

#alternative implementation (same time complexity)
mask_CheckVector2 := function (v)
	return List(v,x->0);
end;


######################################################################################
##
#O  VectorComplexity(<v> , <deg> , <group>)
##
##  This function takes a vector <v> comprising of group elements <mask_element> in "mask format" at any level, the degree <deg> of tree and
##  group <group> as input.
##  It computes the reduced portrait depth for each group element of the vector <v> and returs the sum of the reduced portrait depths. 
##
##  \beginexample
##  gap>  H := AutomatonGroup("e = (f,e,1)(2,3) , f = (1,e,f)(1,2,3)");
##  < e, f >
##  gap> VectorComplexity([mask_function(e*f,2),mask_function(f*f*e,2)],3,H); 
##  4
##  \endexample
##

VectorComplexity := function(v , d , group)

    local i , j ;

    j := 0;

    for i in [1..Length(v)] 
        do 
            j := j + general_new_depth(v[i] , d , group);
        od;
    return j;
end;

#alternative implementation (same time complexity)
VectorComplexity2 := function(v , d , group)
	return Sum(List(v,x->general_new_depth(x , d , group)));
end;

######################################################################################
##
#O  mask_VectorAttack_diff_depth(<k> , <l> , <r_length> , <R> , <d> , <group>)
##
## <k> is the number of entries in the vector
## <l> is the reduced word length of each mask element in the vector
## <r_length> is the reduced word length of the conjugating element
## <R> is radius of the search ball from which we try to construct the conjugator
## <d> is the degree of the tree
## <G> is the group
##  
##This function implements a variant if the suedo code titled Algorithm1 given in the paper


mask_VectorAttack_diff_depth := function(k , l , r_length , R , d , group)

   local v1, v2, v2_gen, v3, v4, v5, r0, r, j, list_of_elements, conjugators, LBA_local_vector, dud_list, c0, vector_generator, random ;

    random := [] ;

    for j in [1..k] do 
        random[j] := Random_Element(l , group) ;
    od;

    vector_generator := function(random , group )
		local j , t , p_depth , v ;

		p_depth := [] ;
		v       := [] ;
 
		for j in [1..k] do 
			p_depth[j] := AutomPortraitDepth(random[j]);
		od;
        #Print(p_depth,"\n");

		for t in [1..k] do 
			v[t] := mask_function(random[t], p_depth[t]);
        od;

		return v ;
    end;

    v1 := vector_generator(random, group) ;
    r0 := Random_Element(r_length , group);
    r  := mask_function(r0 , AutomPortraitDepth(r0)) ;
    v2 := mask_vector_conjugation_diff_depth(v1,r,d) ;
    v3 := mask_output_diff_depth(v1 , v2 , d) ;
    v4 := mask_BinaryVector(v3 , d , group) ;
    v5 := mask_CheckVector(v1) ;
    c0 := VectorComplexity(mask_output_diff_depth(v1, v2 ,d) , d , group) ;
    

    dud_list := [] ;
    
    list_of_elements := ListOfElements(group,R) ;
	conjugators := list_of_elements{[2..Length(list_of_elements)]} ;

    #Print(v1 , "\n") ;
    Print(r0, "\n") ;
    Print(r , "\n") ;
    #Print(v2 , "\n") ;
    #Print(v3 , "\n") ;
    #Print(v4 , "\n") ;
    #Print(v5 , "\n") ;
    Print(c0,"\n");

    if v4 = v5 then 
        return One(group) ;
    fi; 

    LBA_local_vector := function(conj , complexity_value )

        local dd , c , test_vector , conj_result ;

        for dd in conjugators
            do

                if (conj*dd in dud_list) = false then
                    test_vector := mask_output_diff_depth( mask_vector_conjugation_diff_depth(v1 , mask_function(conj*dd , 1),d) , v2 ,d ) ;

                    if mask_BinaryVector(test_vector , d , group) = v5 then
                    #Print(conj*d,"\n") ;
                        return conj*dd ;
                    fi;
                    c := VectorComplexity(test_vector , d , group ) ;
                    #Print(c, "\n") ;

                    if 
                        c >=  c0 then 
                        Append(dud_list , [conj*dd]) ; 
                        #Print(dud_list , "\n");
                    fi;

                    if c < complexity_value then
                        Print(conj*dd , "\n");
                        Print(c ,"\n") ;
                        Append(dud_list, [conj*dd]);
                        conj_result := LBA_local_vector (conj*dd , c ) ;
                        if conj_result <> fail then
                            Print(conj_result, "\n") ;
                            return conj_result ;
                        fi; 
                    fi;
                fi;
            od;
        return fail ; 

    end;

    return [LBA_local_vector(One(group) , c0) , random , r0 , c0] ;
end;


######################################################################################
##
#O  mask_VectorAttack_diff_depth_precomputed(<k> , <l> , <r_length> , <conjugators> , <d> , <group>)
##
## <k> is the number of entries in the vector
## <l> is the reduced word length of each mask element in the vector
## <r_length> is the reduced word length of the conjugating element
## <conjugators> is the precomputed list used to construct the conjugator
## <d> is the degree of the tree
## <G> is the group
##  
##This function implements a variant if the suedo code titled Algorithm1 given in the paper

mask_VectorAttack_diff_depth_precomputed := function(k , l , r_length , conjugators , d , group)

   local v1, v2, v2_gen, v3, v4, v5, r0, r, j, LBA_local_vector, dud_list, c0, vector_generator, random ;

    random := [] ;

    for j in [1..k] do 
        random[j] := Random_Element(l , group) ;
        od;

    vector_generator := function(random , group )
    
    local j , t , p_depth , v ;

    p_depth := [] ;
    v       := [] ;
 
    for j in [1..k] do 
        p_depth[j] := AutomPortraitDepth(random[j]);
        od;
        #Print(p_depth,"\n");

    for t in [1..k] do 
        v[t] := mask_function(random[t], p_depth[t]);
        od;

    return v ;
    end;

    v1 := vector_generator(random, group) ;
    r0 := Random_Element(r_length , group);
    r  := mask_function(r0 , AutomPortraitDepth(r0)) ;
    v2 := mask_vector_conjugation_diff_depth(v1,r,d) ;
    v3 := mask_output_diff_depth(v1 , v2 , d) ;
    v4 := mask_BinaryVector(v3 , d , group) ;
    v5 := mask_CheckVector(v1) ;
    c0 := VectorComplexity(mask_output_diff_depth(v1, v2 ,d) , d , group) ;
    

    dud_list := [] ;
    
    #list_of_elements := ListOfElements(group,R) ;
	#conjugators := list_of_elements{[2..Length(list_of_elements)]} ;

    #Print(v1 , "\n") ;
    Print(r0, "\n") ;
    Print(r , "\n") ;
    #Print(v2 , "\n") ;
    #Print(v3 , "\n") ;
    #Print(v4 , "\n") ;
    #Print(v5 , "\n") ;
    Print(c0,"\n");

    if v4 = v5 then 
        return One(group) ;
    fi; 

    LBA_local_vector := function(conj , complexity_value )

        local dd , c , test_vector , conj_result ;

        for dd in conjugators
            do

                if (conj*dd in dud_list) = false then
                    test_vector := mask_output_diff_depth( mask_vector_conjugation_diff_depth(v1 , mask_function(conj*dd , 1),d) , v2 ,d ) ;

                    if mask_BinaryVector(test_vector , d , group) = v5 then
                    #Print(conj*d,"\n") ;
                        return conj*dd ;
                    fi;
                    c := VectorComplexity(test_vector , d , group ) ;
                    #Print(c, "\n") ;

                    if 
                        c >=  c0 then 
                        Append(dud_list , [conj*dd]) ; 
                        #Print(dud_list , "\n");
                    fi;

                    if c < complexity_value then
                        Print(conj*dd , "\n");
                        Print(c ,"\n") ;
                        Append(dud_list, [conj*dd]);
                        conj_result := LBA_local_vector (conj*dd , c ) ;
                        if conj_result <> fail then
                            Print(conj_result, "\n") ;
                            return conj_result ;
                        fi; 
                    fi;
                fi;
            od;
        return fail ; 

    end;

    return [LBA_local_vector(One(group) , c0) , random , r0 , c0] ;
end;


######################################################################################
##
#O  mask_RunStatsAnalysisVector(<num_runs> , <k> , <l> , <r_length> , <R> , <d> , <group>)
##
## <num_runs> is the number of iterations to be performed. The parameters for each iteration
## are rest of the inputs to this function. 
## <k> is the number of entries in the vector
## <l> is the reduced word length of each mask element in the vector
## <r_length> is the reduced word length of the conjugating element
## <conjugators> is the precomputed list used to construct the conjugator
## <d> is the degree of the tree
## <G> is the group
##  
## This function implements a variant if the suedo code titled Algorithm1 given in the paper and retruns the number 
## of successes. 

mask_RunStatsAnalysisVector := function(num_runs , k , l , r_length , R , d , group)

    local i , num_successes , list_of_elements , conjugators , output_detail ;

    list_of_elements :=ListOfElements(group,R);
	conjugators      := list_of_elements{[2..Length(list_of_elements)]};
    output_detail    := [] ;

    num_successes := 0 ;


    for i in [1..num_runs] do
        output_detail[i] := mask_VectorAttack_diff_depth_precomputed(k , l , r_length , conjugators , d , group) ;
        if output_detail[i][1] <> fail then
        num_successes := num_successes + 1 ;

        Print(num_successes , "\n") ;

        else 
        Print(num_successes , "\n") ;
        fi;
    od; 
    return [ num_successes , output_detail] ;

end;


########################################       END        ##############################################
